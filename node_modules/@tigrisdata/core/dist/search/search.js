"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Search = void 0;
const types_1 = require("./types");
const search_index_1 = require("./search-index");
const utility_1 = require("../utility");
const search_pb_1 = require("../proto/server/v1/search_pb");
const decorated_schema_processor_1 = require("../schema/decorated-schema-processor");
class Search {
    constructor(client, config) {
        this.client = client;
        this.config = config;
        this.schemaProcessor = decorated_schema_processor_1.DecoratedSchemaProcessor.Instance;
    }
    createOrUpdateIndex(nameOrClass, schema) {
        let indexName;
        if (typeof nameOrClass === "string") {
            indexName = nameOrClass;
        }
        else {
            const generatedIndex = this.schemaProcessor.processIndex(nameOrClass);
            indexName = generatedIndex.name;
            schema = generatedIndex.schema;
        }
        const rawJSONSchema = utility_1.Utility._indexSchematoJSON(indexName, schema);
        const createOrUpdateIndexRequest = new search_pb_1.CreateOrUpdateIndexRequest()
            .setProject(this.projectName)
            .setName(indexName)
            .setSchema(utility_1.Utility.stringToUint8Array(rawJSONSchema));
        return new Promise((resolve, reject) => {
            this.client.createOrUpdateIndex(createOrUpdateIndexRequest, (error, response) => {
                if (error) {
                    reject(error);
                    return;
                }
                console.log(`Created index: ${response.getMessage()}`);
                resolve(new search_index_1.SearchIndex(this.client, indexName, this.config));
            });
        });
    }
    listIndexes() {
        // TODO: Set filter on request
        const listIndexRequest = new search_pb_1.ListIndexesRequest().setProject(this.projectName);
        return new Promise((resolve, reject) => {
            this.client.listIndexes(listIndexRequest, (error, response) => {
                if (error) {
                    reject(error);
                    return;
                }
                resolve(response.getIndexesList().map((i) => types_1.IndexInfo.from(i)));
            });
        });
    }
    getIndex(name) {
        const getIndexRequest = new search_pb_1.GetIndexRequest().setProject(this.projectName).setName(name);
        return new Promise((resolve, reject) => {
            this.client.getIndex(getIndexRequest, (error, response) => {
                if (error) {
                    reject(error);
                    return;
                }
                if (response.hasIndex()) {
                    resolve(new search_index_1.SearchIndex(this.client, name, this.config));
                }
            });
        });
    }
    deleteIndex(name) {
        const deleteIndexRequest = new search_pb_1.DeleteIndexRequest()
            .setProject(this.projectName)
            .setName(name);
        return new Promise((resolve, reject) => {
            this.client.deleteIndex(deleteIndexRequest, (error, response) => {
                if (error) {
                    reject(error);
                    return;
                }
                resolve(types_1.DeleteIndexResponse.from(response));
            });
        });
    }
    get projectName() {
        return this.config.projectName;
    }
}
exports.Search = Search;
